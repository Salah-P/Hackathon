rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for validation
    function isValidTimestamp(timestamp) {
      return timestamp is timestamp && timestamp <= request.time;
    }
    
    function isValidRating(rating) {
      return rating is number && rating >= 1 && rating <= 5;
    }
    
    function isValidSeatCount(seats) {
      return seats is number && seats >= 0;
    }
    
    function isValidUserId(userId) {
      return userId is string && userId.size() > 0;
    }
    
    function isValidEmail(email) {
      return email is string && email.matches('.*@.*\\..*');
    }
    
    function isValidDate(dateString) {
      return dateString is string && dateString.size() > 0;
    }
    
    function isValidTime(timeString) {
      return timeString is string && timeString.matches('[0-9]{2}:[0-9]{2}');
    }
    
    // Users collection - allow read/write for all users (no auth yet)
    match /users/{userId} {
      allow read, write: if true;
      
      // Validation for user documents
      allow create: if isValidUserId(userId) &&
        request.resource.data.keys().hasAll(['name', 'email', 'userId']) &&
        request.resource.data.name is string &&
        request.resource.data.name.size() > 0 &&
        isValidEmail(request.resource.data.email) &&
        request.resource.data.userId == userId &&
        request.resource.data.averageRating is number &&
        request.resource.data.averageRating >= 0 &&
        request.resource.data.ridesGiven is number &&
        request.resource.data.ridesGiven >= 0 &&
        request.resource.data.ridesTaken is number &&
        request.resource.data.ridesTaken >= 0 &&
        request.resource.data.ratingCount is number &&
        request.resource.data.ratingCount >= 0 &&
        isValidTimestamp(request.resource.data.createdAt) &&
        isValidTimestamp(request.resource.data.updatedAt) &&
        // Profile picture URL validation (optional)
        (request.resource.data.profilePictureUrl == null ||
         (request.resource.data.profilePictureUrl is string && 
          request.resource.data.profilePictureUrl.size() > 0));
        
      allow update: if isValidUserId(userId) &&
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['userId', 'createdAt'])) &&
        (request.resource.data.name is string && request.resource.data.name.size() > 0) &&
        isValidEmail(request.resource.data.email) &&
        request.resource.data.averageRating is number &&
        request.resource.data.averageRating >= 0 &&
        request.resource.data.ridesGiven is number &&
        request.resource.data.ridesGiven >= 0 &&
        request.resource.data.ridesTaken is number &&
        request.resource.data.ridesTaken >= 0 &&
        request.resource.data.ratingCount is number &&
        request.resource.data.ratingCount >= 0 &&
        isValidTimestamp(request.resource.data.updatedAt) &&
        // Profile picture URL validation (optional)
        (request.resource.data.profilePictureUrl == null ||
         (request.resource.data.profilePictureUrl is string && 
          request.resource.data.profilePictureUrl.size() > 0));
    }
    
    // Trips collection - allow read/write for all users (no auth yet)
    match /trips/{tripId} {
      allow read, write: if true;
      
      // Validation for trip documents
      allow create: if request.resource.data.keys().hasAll(['driverId', 'from', 'to', 'date', 'time', 'totalSeats', 'seatsLeft', 'status']) &&
        isValidUserId(request.resource.data.driverId) &&
        request.resource.data.from is string &&
        request.resource.data.from.size() > 0 &&
        request.resource.data.to is string &&
        request.resource.data.to.size() > 0 &&
        isValidDate(request.resource.data.date) &&
        isValidTime(request.resource.data.time) &&
        request.resource.data.totalSeats is number &&
        request.resource.data.totalSeats > 0 &&
        isValidSeatCount(request.resource.data.seatsLeft) &&
        request.resource.data.seatsLeft <= request.resource.data.totalSeats &&
        request.resource.data.status in ['active', 'completed', 'cancelled'] &&
        isValidTimestamp(request.resource.data.createdAt) &&
        isValidTimestamp(request.resource.data.updatedAt) &&
        // Validate coordinates if provided
        (request.resource.data.fromCoordinates == null || 
         (request.resource.data.fromCoordinates.latitude is number &&
          request.resource.data.fromCoordinates.longitude is number &&
          request.resource.data.fromCoordinates.address is string)) &&
        (request.resource.data.toCoordinates == null || 
         (request.resource.data.toCoordinates.latitude is number &&
          request.resource.data.toCoordinates.longitude is number &&
          request.resource.data.toCoordinates.address is string));
          
      allow update: if request.resource.data.status in ['active', 'completed', 'cancelled'] &&
        isValidSeatCount(request.resource.data.seatsLeft) &&
        isValidTimestamp(request.resource.data.updatedAt) &&
        // Ensure seatsLeft doesn't exceed totalSeats
        request.resource.data.seatsLeft <= request.resource.data.totalSeats;
    }
    
    // Bookings collection - allow read/write for all users (no auth yet)
    match /bookings/{bookingId} {
      allow read, write: if true;
      
      // Validation for booking documents
      allow create: if request.resource.data.keys().hasAll(['tripId', 'passengerId', 'status']) &&
        isValidUserId(request.resource.data.tripId) &&
        isValidUserId(request.resource.data.passengerId) &&
        request.resource.data.status in ['pending', 'confirmed', 'declined'] &&
        isValidTimestamp(request.resource.data.createdAt) &&
        isValidTimestamp(request.resource.data.updatedAt);
        
      allow update: if request.resource.data.status in ['pending', 'confirmed', 'declined'] &&
        isValidTimestamp(request.resource.data.updatedAt) &&
        // Prevent changing tripId and passengerId
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['tripId', 'passengerId', 'createdAt']));
    }
    
    // Ratings collection - allow read/write for all users (no auth yet)
    match /ratings/{ratingId} {
      allow read, write: if true;
      
      // Validation for rating documents
      allow create: if request.resource.data.keys().hasAll(['tripId', 'raterId', 'rateeId', 'rating', 'role']) &&
        isValidUserId(request.resource.data.tripId) &&
        isValidUserId(request.resource.data.raterId) &&
        isValidUserId(request.resource.data.rateeId) &&
        isValidRating(request.resource.data.rating) &&
        request.resource.data.role in ['driver', 'passenger'] &&
        isValidTimestamp(request.resource.data.createdAt) &&
        // Prevent duplicate ratings from same rater to same ratee for same trip
        request.resource.data.raterId != request.resource.data.rateeId;
        
      // Ratings cannot be updated or deleted once created
      allow update, delete: if false;
    }
    
    // Posts collection - allow read/write for all users (no auth yet)
    match /posts/{postId} {
      allow read, write: if true;
      
      // Validation for post documents
      allow create: if request.resource.data.keys().hasAll(['title', 'content', 'authorId']) &&
        request.resource.data.title is string &&
        request.resource.data.title.size() > 0 &&
        request.resource.data.content is string &&
        request.resource.data.content.size() > 0 &&
        isValidUserId(request.resource.data.authorId) &&
        isValidTimestamp(request.resource.data.createdAt) &&
        isValidTimestamp(request.resource.data.updatedAt);
        
      allow update: if request.resource.data.title is string &&
        request.resource.data.title.size() > 0 &&
        request.resource.data.content is string &&
        request.resource.data.content.size() > 0 &&
        isValidTimestamp(request.resource.data.updatedAt) &&
        // Prevent changing authorId and createdAt
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['authorId', 'createdAt']));
    }
  }
}
